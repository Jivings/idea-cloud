{
  "name": "rio",
  "description": "Integration with Rserve, a TCP/IP server for R framework",
  "version": "0.7.0",
  "main": "index",
  "repository": {
    "type": "git",
    "url": "http://github.com/albertosantini/node-rio"
  },
  "keywords": [
    "Rserve",
    "R framework"
  ],
  "author": {
    "name": "Alberto Santini"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/albertosantini/node-rio/raw/master/LICENSE"
    }
  ],
  "engines": {
    "node": ">=0.8.x"
  },
  "dependencies": {
    "hexy": ">=0.2.4",
    "binary": ">=0.3.0"
  },
  "scripts": {
    "test": "vows --spec"
  },
  "devDependencies": {
    "vows": "~0.7.0"
  },
  "readme": "RIO\r\n======\r\n[![Build Status](https://travis-ci.org/albertosantini/node-rio.png)](https://travis-ci.org/albertosantini/node-rio)\r\n\r\nRIO, R Input Output, connects an app to [Rserve](http://www.rforge.net/Rserve/),\r\na TCP/IP server which allows other programs to use facilities of [R](http://www.r-project.org).\r\n\r\nIt supports double, double array, string and string array objects.\r\n\r\nIt supports also the plain text authentication, if Rserve is configured for that\r\ncapability.\r\n\r\nThe main goal is to pass a string containing a script call using a JSON object\r\nas parameter. Then, inside the script, using rjsonio package, deserializing\r\nthe JSON object, calling a method, serializing the response and returning to\r\nNodeJS.\r\n\r\nExample\r\n========\r\n\r\n    var rio = require('rio');\r\n\r\n    rio.evaluate(\"pi / 2 * 2\");\r\n    rio.evaluate('c(1, 2)');\r\n    rio.evaluate(\"as.character('Hello World')\");\r\n    rio.evaluate('c(\"a\", \"b\")');\r\n    rio.evaluate('Sys.sleep(5); 11')\r\n\r\nSee examples directory.\r\n\r\nInstallation\r\n============\r\n\r\nTo install with [npm](http://github.com/isaacs/npm):\r\n\r\n    npm install rio\r\n\r\nTested with node 0.10.0 and Rserve 0.6.8 (on Windows 7) with R 2.15.3.\r\n\r\nDon't forget to start [Rserve](http://cran.r-project.org/web/packages/Rserve/).\r\nFor instance, from R console, after installing the package Rserve:\r\n\r\n    require('Rserve')\r\n    Rserve()\r\n\r\nTo shutdown the server from R console:\r\n\r\n    require('Rserve')\r\n    c <- RSconnect()\r\n    RSshutdown(c)\r\n\r\nMethods\r\n=======\r\n\r\nevaluate(command, options)\r\n--------\r\n\r\nEvaluate a command, connecting to Rserve, executing the command and then\r\ndisconnecting.\r\n\r\nThe defaults for the options parameter:\r\n\r\n    options = {\r\n        callback: function (err, res) {\r\n            if (err) {\r\n                util.puts(res);\r\n            } else {\r\n                util.puts(\"Rserve call failed\");\r\n            }\r\n        },\r\n        host = \"127.0.0.1\",\r\n        port = 6311,\r\n        user = \"anon\",\r\n        password = \"anon\"\r\n    }\r\n\r\n\r\nsourceAndEval(filename, options)\r\n-------------\r\n\r\nIt loads the content of a R file and calls the \"evaluate\" method, merging,\r\nfinally, the options parameter:\r\n\r\n    options = {\r\n        entryPoint: \"main\", // entryPoint is called\r\n        data: { foo: \"bar\" } // data is stringified and passed to entryPoint\r\n    }\r\n\r\nenableDebug(isDebug)\r\n-----------\r\n\r\nIt enables debugging mode, printing the packet and logging messages.\r\n\r\nenableRecordMode(isRecordMode, options)\r\n----------------\r\n\r\nIt enables record mode, dumping the incoming data to a file specified in the\r\noptions.\r\n\r\n    options = {\r\n        fileName: \"node-rio-dump.bin\"\r\n    }\r\n\r\nenablePlaybackMode(isPlaybackMode, options)\r\n------------------\r\n\r\nIt enables playback mode, reading a dump file instead connecting to the server.\r\n\r\n    options = {\r\n        fileName: \"node-rio-dump.bin\"\r\n    }\r\n",
  "_id": "rio@0.7.0",
  "dist": {
    "shasum": "8f3076a078f5518a01906bddab62033a8e189c00"
  },
  "_from": "rio"
}
